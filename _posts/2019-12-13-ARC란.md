---
layout: post
title: ARC
tags: Swift
color: gray
author: 두부
excerpt_separator: <!--more-->
---

# ARC #

## ARC란? ##

오늘은 ARC에 대해 알아보겠습니다. ARC는 Aoutomatic Reference Counting 의 약자로 말 그대로 레퍼런스를 자동으로 카운팅해주는 기능이에요. ARC는 컴파일 시점부터 시작됩니다. 코드를 빌드할 때 특정 객체의 레퍼런스 카운트를 추적하여 class와 같은 객체를 생성할때 생성된 레퍼런스의 카운팅을 함으로써 선언, 언급시 +1, 사용완료시 -1 식으로 카운팅을 해서 카운팅 숫자가 0이 되면 free 시켜주는 형식으로 진행되요.

## ARC의 문제점 ##

ARC는 C나 C++에서 메모리를 개발자가 관리해줘야 했던 부분들을 자동으로 관리해주는 편리한 기능이지만, 이로인해 메모리 누수가 생길 수 있는 문제점이 생길 수가 있어요. 바로 순환참조인데,

Class A는 Class B를 참조하고, Class B는 Class A를 참조했을 경우, 서로 참조로 인한 카운팅+1과 사용으로 인한 -1이 무한 반복되면서 메모리 free가 되지 않는 문제점이 발생할 수 있습니다. 이러한 문제를 해결하기 위해 있는 키워드가 바로 Strong, Weak, Unowned입니다.

## Strong ##

이 키워드로 선언된 레퍼런스 객체는 할당되는 순간 해당 객체의 레퍼런스 카운트를 추가로 +1 더 증가시킵니다. 즉 총 +2가 증가되는데, 왜 이렇게 하는걸까요??

추가로 +1을 더 증가시켜줌으로써 ARC로 인한 메모리해제를 피하고 이로써 객체를 좀 더 안전하게 사용하고자 이 키워드를 사용합니다.

즉 원래는 메소드의 사용이 끝나는 순간 해당 레퍼런스 객체의 카운트는 1 감소하는게 정상인데, strong타입을 사용함으로써 카운트 증가가 +1이 아닌 +2가 증가되어 사용-1이 되어도 free가 되지 않는거죠. 즉 더 사용하고 싶을때, 안전하게 사용하고자 할 때 사용하는 키워드가 Strong 입니다.

## Weak ##

weak은 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않습니다. (이 키워드는 옵셔널 타입에만 적용) 그리고 객체가 ARC에 의해 메모리해제되면 nil 값이 반환됩니다.(옵셔널이기 때문에)

대표적으로 retain cycle에 의해 메모리 누수 문제를 막기 위해 사용되며, iOS 프레임워크의 대표적 예로 Delegate 패턴이 있습니다.

## Unowned ##

언노운 또한 마찬가지로 객체가 할당될 때 레퍼런스 카운트를 증가시키지 않습니다.(이 키워드는 논옵셔널 타입에만 된다)

특이한 점은 객체가 ARC에 의해 메모리가 헤제되더라도 해당 객체 값이 존재하는 것으로 인지하여, 해당 객체에 액세스를 할 경우 런타임 오류를 발생시킨다..

> 음.. 그럼 언노운은 왜쓰는걸까?.. =\_=